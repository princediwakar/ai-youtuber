// lib/visuals/layouts/layoutSelector.ts
import { Canvas } from 'canvas';
import { QuizJob } from '@/lib/types';
import { Theme } from '@/lib/visuals/themes';
import * as mcqLayout from './mcqLayout';
import * as quickTipLayout from './quickTipLayout';
import * as simplifiedWordLayout from './simplifiedWordLayout';

export type LayoutType = 'mcq' | 'quick_tip' | 'simplified_word';

export interface LayoutDefinition {
    type: LayoutType;
    frames: string[];
    renderers: {
        [key: string]: (canvas: Canvas, job: QuizJob, theme: Theme) => void;
    };
}

// Layout definitions for all supported formats
export const layouts: Record<LayoutType, LayoutDefinition> = {
    simplified_word: {
        type: 'simplified_word',
        // Single frame format
        frames: ['word'],
        renderers: {
            word: simplifiedWordLayout.renderWordFrame,
        },
    },
    mcq: {
        type: 'mcq',
        frames: ['question', 'answer', 'explanation', 'cta'],
        renderers: {
            question: mcqLayout.renderQuestionFrame,
            answer: mcqLayout.renderAnswerFrame,
            explanation: mcqLayout.renderExplanationFrame,
            cta: mcqLayout.renderCtaFrame,
        },
    },
    quick_tip: {
        type: 'quick_tip',
        // Complete video sequence
        frames: ['action', 'result', 'cta'],
        renderers: {
            action: quickTipLayout.renderActionFrame,
            result: quickTipLayout.renderResultFrame,
            cta: mcqLayout.renderCtaFrame,
        },
    },

};

/**
 * Dynamically detects the layout type based on the generated content structure.
 */
export function detectLayoutType(contentData: any): LayoutType {
    if (!contentData) {
        return 'mcq'; // Proven default
    }

    const detectedKeys = Object.keys(contentData);
    console.log(`üîç Layout detection: content has keys: ${detectedKeys.join(', ')}`);

    // PRIORITY 1: Check for explicit format type generated by the AI
    if (contentData.format_type && layouts[contentData.format_type as LayoutType]) {
        const layoutType = contentData.format_type as LayoutType;
        // Verify structure against keys for robust detection
        if (layoutType === 'simplified_word' && detectedKeys.includes('word') && detectedKeys.includes('definition')) {
            console.log(`‚úÖ Detected simplified_word layout via format_type key.`);
            return layoutType;
        }
        // Fallback to the format_type if a structured format key is present.
        if (layoutType !== 'mcq' && layoutType !== 'quick_tip') {
             console.log(`‚úÖ Detected layout via format_type key: ${layoutType}`);
             return layoutType;
        }
    }


    // PRIORITY 2: Detect quick_tip structure for health content
    const hasQuickTipStructure = detectedKeys.includes('action') &&
                                 detectedKeys.includes('result') &&
                                 !detectedKeys.includes('question') &&
                                 !detectedKeys.includes('options');

    if (hasQuickTipStructure) {
        console.log(`‚úÖ Detected quick_tip layout structure.`);
        return 'quick_tip';
    }

    // PRIORITY 3: Detect MCQ/Quiz structure (the proven fallback)
    const hasMCQStructure = detectedKeys.includes('question') &&
                             detectedKeys.includes('options');

    if (hasMCQStructure) {
        console.log(`‚úÖ Detected MCQ layout structure - using proven format.`);
        return 'mcq';
    }
    
    // FINAL DEFAULT
    console.log(`üéØ Using MCQ layout (proven default format)`);
    return 'mcq';
}

/**
 * Get layout definition
 * FIX: Added robust error handling.
 */
export function getLayout(layoutType: LayoutType): LayoutDefinition {
    const layout = layouts[layoutType];
    if (!layout) {
        throw new Error(`Layout type "${layoutType}" not found in layouts dictionary.`);
    }
    return layout;
}

/**
 * Create render functions for a layout
 */
export function createRenderFunctions(
    layoutType: LayoutType,
    job: QuizJob,
    theme: Theme
): Array<(canvas: Canvas) => void> {
    
    // No explicit forcing or overriding here, trust the generation service selection
    let finalLayoutType = layoutType;
    
    try {
        const layout = getLayout(finalLayoutType);
    } catch (e) {
        // Fallback to proven MCQ if layout not found
        console.warn(`Layout ${finalLayoutType} not found, falling back to MCQ`);
        finalLayoutType = 'mcq';
    }

    const finalLayout = getLayout(finalLayoutType);
    
    console.log(`‚úÖ Using render functions for layout: ${finalLayoutType}`);

    return finalLayout.frames.map(frameType => {
        const renderer = finalLayout.renderers[frameType];
       
        return (canvas: Canvas) => renderer(canvas, job, theme);
    });
}