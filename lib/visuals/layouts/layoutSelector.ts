// lib/visuals/layouts/layoutSelector.ts
import { Canvas } from 'canvas';
import { QuizJob } from '@/lib/types';
import { Theme } from '@/lib/visuals/themes';
import * as mcqLayout from './mcqLayout';
import * as quickTipLayout from './quickTipLayout';
import * as commonMistakeLayout from './commonMistakeLayout';
import * as quickFixLayout from './quickFixLayout';
import * as usageDemoLayout from './usageDemoLayout';
import * as simplifiedWordLayout from './simplifiedWordLayout';

export type LayoutType = 'mcq' | 'quick_tip' | 'common_mistake' | 'quick_fix' | 'usage_demo' | 'simplified_word';

export interface LayoutDefinition {
    type: LayoutType;
    frames: string[];
    renderers: {
        [key: string]: (canvas: Canvas, job: QuizJob, theme: Theme) => void;
    };
}

// Layout definitions for all supported formats
export const layouts: Record<LayoutType, LayoutDefinition> = {
    simplified_word: {
        type: 'simplified_word',
        // Single frame format
        frames: ['word'],
        renderers: {
            word: simplifiedWordLayout.renderWordFrame,
        },
    },
    mcq: {
        type: 'mcq',
        frames: ['hook', 'question', 'answer', 'explanation', 'cta'],
        renderers: {
            hook: mcqLayout.renderHookFrame,
            question: mcqLayout.renderQuestionFrame,
            answer: mcqLayout.renderAnswerFrame,
            explanation: mcqLayout.renderExplanationFrame,
            cta: mcqLayout.renderCtaFrame,
        },
    },
    quick_tip: {
        type: 'quick_tip',
        // Complete video sequence
        frames: ['hook', 'action', 'result', 'cta'],
        renderers: {
            hook: quickTipLayout.renderHookFrame,
            action: quickTipLayout.renderActionFrame,
            result: quickTipLayout.renderResultFrame,
            cta: mcqLayout.renderCtaFrame,
        },
    },
    common_mistake: {
        type: 'common_mistake',
        // Flow: Hook -> Mistake -> Correct -> Practice -> Explanation -> CTA
        frames: ['hook', 'mistake', 'correct', 'practice', 'explanation', 'cta'],
        renderers: {
            hook: commonMistakeLayout.renderHookFrame,
            mistake: commonMistakeLayout.renderMistakeFrame,
            correct: commonMistakeLayout.renderCorrectFrame,
            // ASSUMPTION: A renderPracticeFrame exists in commonMistakeLayout
            practice: commonMistakeLayout.renderPracticeFrame,
            explanation: mcqLayout.renderExplanationFrame,
            cta: mcqLayout.renderCtaFrame,
        },
    },
    quick_fix: {
        type: 'quick_fix',
        // Flow: Hook -> Basic -> Advanced -> CTA
        frames: ['hook', 'basic_word', 'advanced_word', 'cta'],
        renderers: {
            hook: quickFixLayout.renderHookFrame,
            basic_word: quickFixLayout.renderBasicWordFrame,
            advanced_word: quickFixLayout.renderAdvancedWordFrame,
            cta: mcqLayout.renderCtaFrame,
        },
    },
    usage_demo: {
        type: 'usage_demo',
        // Flow: Hook -> Wrong -> Right -> Practice -> CTA
        frames: ['hook', 'wrong_example', 'right_example', 'practice', 'cta'],
        renderers: {
            hook: usageDemoLayout.renderHookFrame,
            wrong_example: usageDemoLayout.renderWrongExampleFrame,
            right_example: usageDemoLayout.renderRightExampleFrame,
            practice: usageDemoLayout.renderPracticeFrame,
            cta: mcqLayout.renderCtaFrame,
        },
    },

};

/**
 * Dynamically detects the layout type based on the generated content structure.
 */
export function detectLayoutType(contentData: any): LayoutType {
    if (!contentData) {
        return 'mcq'; // Proven default
    }

    const detectedKeys = Object.keys(contentData);
    console.log(`üîç Layout detection: content has keys: ${detectedKeys.join(', ')}`);

    // PRIORITY 1: Check for explicit format type generated by the AI
    if (contentData.format_type && layouts[contentData.format_type as LayoutType]) {
        const layoutType = contentData.format_type as LayoutType;
        // Verify structure against keys for robust detection
        if (layoutType === 'common_mistake' && detectedKeys.includes('mistake') && detectedKeys.includes('correct')) {
            console.log(`‚úÖ Detected common_mistake layout via format_type key.`);
            return layoutType;
        }
        if (layoutType === 'usage_demo' && detectedKeys.includes('wrong_example') && detectedKeys.includes('right_example')) {
            console.log(`‚úÖ Detected usage_demo layout via format_type key.`);
            return layoutType;
        }
        if (layoutType === 'simplified_word' && detectedKeys.includes('word') && detectedKeys.includes('definition')) {
            console.log(`‚úÖ Detected simplified_word layout via format_type key.`);
            return layoutType;
        }
        // Fallback to the format_type if a structured format key is present.
        if (layoutType !== 'mcq' && layoutType !== 'quick_tip') {
             console.log(`‚úÖ Detected layout via format_type key: ${layoutType}`);
             return layoutType;
        }
    }


    // PRIORITY 2: Detect quick_tip structure for health content
    const hasQuickTipStructure = detectedKeys.includes('hook') &&
                                 detectedKeys.includes('action') &&
                                 detectedKeys.includes('result') &&
                                 !detectedKeys.includes('question') &&
                                 !detectedKeys.includes('options');

    if (hasQuickTipStructure) {
        console.log(`‚úÖ Detected quick_tip layout structure.`);
        return 'quick_tip';
    }

    // PRIORITY 3: Detect MCQ/Quiz structure (the proven fallback)
    const hasMCQStructure = detectedKeys.includes('question') &&
                             detectedKeys.includes('options');

    if (hasMCQStructure) {
        console.log(`‚úÖ Detected MCQ layout structure - using proven format.`);
        return 'mcq';
    }
    
    // FINAL DEFAULT
    console.log(`üéØ Using MCQ layout (proven default format)`);
    return 'mcq';
}

/**
 * Get layout definition
 * FIX: Added robust error handling.
 */
export function getLayout(layoutType: LayoutType): LayoutDefinition {
    const layout = layouts[layoutType];
    if (!layout) {
        throw new Error(`Layout type "${layoutType}" not found in layouts dictionary.`);
    }
    return layout;
}

/**
 * Create render functions for a layout
 */
export function createRenderFunctions(
    layoutType: LayoutType,
    job: QuizJob,
    theme: Theme
): Array<(canvas: Canvas) => void> {
    
    // No explicit forcing or overriding here, trust the generation service selection
    let finalLayoutType = layoutType;
    
    try {
        const layout = getLayout(finalLayoutType);
    } catch (e) {
        // Fallback to proven MCQ if layout not found
        console.warn(`Layout ${finalLayoutType} not found, falling back to MCQ`);
        finalLayoutType = 'mcq';
    }

    const finalLayout = getLayout(finalLayoutType);
    
    console.log(`‚úÖ Using render functions for layout: ${finalLayoutType}`);

    return finalLayout.frames.map(frameType => {
        const renderer = finalLayout.renderers[frameType];
        if (!renderer) {
            // Fallback to hook is safer than crashing, but logs a warning
            console.warn(`No renderer found for frame type: ${frameType} in ${finalLayoutType} layout. Falling back to Hook.`);
            return (canvas: Canvas) => finalLayout.renderers.hook(canvas, job, theme);
        }
        return (canvas: Canvas) => renderer(canvas, job, theme);
    });
}